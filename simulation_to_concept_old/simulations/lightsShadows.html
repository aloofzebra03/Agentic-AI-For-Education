<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Light & Shadows Explorer - Interactive Simulation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f9f9f9;
        }
        #app {
            max-width: 600px;
            margin: 0 auto;
            padding: 16px;
            background: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        header {
            padding: 16px 0;
            text-align: center;
            border-bottom: 2px solid #e0e0e0;
            margin-bottom: 16px;
        }
        h1 { font-size: 24px; margin-bottom: 8px; }
        .subtitle { font-size: 14px; color: #666; }

        #visual-area {
            position: relative;
            height: 50vh;
            min-height: 300px;
            background: #f5f5f5;
            border-radius: 8px;
            margin-bottom: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            flex-grow: 1;
        }

        #simulation-svg {
            width: 100%;
            height: 100%;
        }

        #light-source, #object, #shadow-projection, .light-ray {
            transition: all 0.3s ease-out;
        }

        #controls {
            padding: 16px;
            background: #fafafa;
            border-radius: 8px;
            margin-bottom: 16px;
        }

        .control-group {
            margin-bottom: 16px;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-weight: 500;
            font-size: 16px;
        }

        input[type="range"] {
            width: 100%;
            height: 48px;
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
            background: #e0e0e0;
            border-radius: 24px;
            outline: none;
            padding: 0;
            margin: 0;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #007AFF;
            cursor: grab;
            border: 2px solid white;
            box-shadow: 0 0 4px rgba(0,0,0,0.2);
        }

        input[type="range"]::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #007AFF;
            cursor: grab;
            border: 2px solid white;
            box-shadow: 0 0 4px rgba(0,0,0,0.2);
        }

        .segmented-control {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .segmented-control button {
            flex: 1;
            min-width: 48px;
            min-height: 48px;
            padding: 10px;
            border-radius: 8px;
            background-color: #E0E0E0;
            color: #333;
            border: none;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease, transform 0.1s ease;
            margin: 0;
        }

        .segmented-control button.active {
            background-color: #007AFF;
            color: white;
            font-weight: bold;
        }

        .segmented-control button:active {
            transform: scale(0.98);
        }

        #info {
            padding: 16px;
            background: #e3f2fd;
            border-radius: 8px;
            margin-bottom: 16px;
            font-size: 0.9em;
        }

        .info-label {
            font-weight: bold;
        }

        .light-ray {
            stroke: #FFD700;
            stroke-width: 2;
        }

        #light-source {
            fill: #FFD700;
        }

        #object {
            fill: #888888;
            stroke: #333333;
            stroke-width: 1;
        }

        #screen-wall {
            fill: #EEEEEE;
            stroke: #CCCCCC;
            stroke-width: 1;
        }

        #shadow-projection {
            fill: #333333;
            opacity: 1;
            filter: none;
        }
    </style>
</head>
<body>
    <div id="app">
        <header>
            <h1>Light & Shadows Explorer</h1>
            <p class="subtitle">See how light creates shadows!</p>
        </header>

        <div id="visual-area">
            <svg id="simulation-svg" viewBox="0 0 1000 500">
                <defs>
                    <filter id="fuzzyShadow" x="-50%" y="-50%" width="200%" height="200%">
                        <feGaussianBlur in="SourceGraphic" stdDeviation="5" result="blur"></feGaussianBlur>
                        <feComponentTransfer>
                            <feFuncA type="linear" slope="0.7"></feFuncA>
                        </feComponentTransfer>
                        <feMerge>
                            <feMergeNode in="blur"></feMergeNode>
                            <feMergeNode in="SourceGraphic"></feMergeNode>
                        </feMerge>
                    </filter>
                </defs>

                <rect id="screen-wall" x="850" y="50" width="20" height="400"></rect>

                <line id="ray-top-ls-obj" class="light-ray"></line>
                <line id="ray-bottom-ls-obj" class="light-ray"></line>
                <line id="ray-top-obj-screen" class="light-ray"></line>
                <line id="ray-bottom-obj-screen" class="light-ray"></line>

                <rect id="object" x="400" y="200" width="50" height="100"></rect>

                <circle id="light-source" cx="150" cy="250" r="20"></circle>

                <rect id="shadow-projection" x="850" y="50" width="20" height="400"></rect>

            </svg>
        </div>

        <div id="controls">
            <div class="control-group">
                <label for="light-distance-slider" class="control-label">
                    Light Distance: <span id="light-distance-value">5 units</span>
                </label>
                <input type="range" id="light-distance-slider" min="1" max="10" value="5"/>
            </div>

            <div class="control-group">
                <label class="control-label">Object Type:</label>
                <div class="segmented-control">
                    <button id="opaque-btn" class="active">Opaque</button>
                    <button id="translucent-btn">Translucent</button>
                    <button id="transparent-btn">Transparent</button>
                </div>
            </div>

            <div class="control-group">
                <label for="object-size-slider" class="control-label">
                    Object Size: <span id="object-size-value">5 units</span>
                </label>
                <input type="range" id="object-size-slider" min="1" max="10" value="5"/>
            </div>
        </div>

        <div id="info">
            <p><span class="info-label">Current Object:</span> <span id="current-object-type">Opaque</span></p>
            <p><span class="info-label">Shadow State:</span> <span id="current-shadow-state">Dark & Clear</span></p>
        </div>
    </div>

    <script>
        const lightDistanceSlider = document.getElementById('light-distance-slider');
        const objectSizeSlider = document.getElementById('object-size-slider');
        const opaqueBtn = document.getElementById('opaque-btn');
        const translucentBtn = document.getElementById('translucent-btn');
        const transparentBtn = document.getElementById('transparent-btn');

        const lightDistanceValueSpan = document.getElementById('light-distance-value');
        const objectSizeValueSpan = document.getElementById('object-size-value');
        const currentObjectTypeSpan = document.getElementById('current-object-type');
        const currentShadowStateSpan = document.getElementById('current-shadow-state');

        const lightSourceSvg = document.getElementById('light-source');
        const objectSvg = document.getElementById('object');
        const screenWallSvg = document.getElementById('screen-wall');
        const shadowSvg = document.getElementById('shadow-projection');
        const rayTopLsObj = document.getElementById('ray-top-ls-obj');
        const rayBottomLsObj = document.getElementById('ray-bottom-ls-obj');
        const rayTopObjScreen = document.getElementById('ray-top-obj-screen');
        const rayBottomObjScreen = document.getElementById('ray-bottom-obj-screen');

        let lightDistance = parseFloat(lightDistanceSlider.value);
        let objectType = 'Opaque';
        let objectSize = parseFloat(objectSizeSlider.value);

        const SVG_VIEW_WIDTH = 1000;
        const SVG_VIEW_HEIGHT = 500;
        const SCREEN_X_COORD = parseFloat(screenWallSvg.getAttribute('x'));
        const SCREEN_WIDTH = parseFloat(screenWallSvg.getAttribute('width'));

        const LS_CENTER_Y = SVG_VIEW_HEIGHT / 2;
        const OBJ_FIXED_X = parseFloat(objectSvg.getAttribute('x'));

        function getIntersectionWithVerticalLine(x1, y1, x2, y2, x_intersect) {
            if (x2 === x1) {
                return { x: x_intersect, y: y1 + (y2 > y1 ? 1 : -1) * 1000 };
            }
            const slope = (y2 - y1) / (x2 - x1);
            const y_intersect = y1 + slope * (x_intersect - x1);
            return { x: x_intersect, y: y_intersect };
        }

        function updateVisuals() {
            try {
                const currentLsX = 50 + (lightDistance - 1) * (200 / 9);
                lightSourceSvg.setAttribute('cx', currentLsX);
                lightDistanceValueSpan.textContent = `${lightDistance.toFixed(0)} units`;

                const currentObjWidth = 20 + (objectSize - 1) * (60 / 9);
                const currentObjHeight = 40 + (objectSize - 1) * (120 / 9);
                const currentObjY = LS_CENTER_Y - currentObjHeight / 2;

                objectSvg.setAttribute('width', currentObjWidth);
                objectSvg.setAttribute('height', currentObjHeight);
                objectSvg.setAttribute('y', currentObjY);
                objectSizeValueSpan.textContent = `${objectSize.toFixed(0)} units`;

                const lsX = currentLsX;
                const lsY = LS_CENTER_Y;

                const objX = OBJ_FIXED_X;
                const objY_top = currentObjY;
                const objY_bottom = currentObjY + currentObjHeight;

                const shadowTopPoint = getIntersectionWithVerticalLine(lsX, lsY, objX, objY_top, SCREEN_X_COORD);
                const shadowBottomPoint = getIntersectionWithVerticalLine(lsX, lsY, objX, objY_bottom, SCREEN_X_COORD);

                const shadowY = shadowTopPoint.y;
                const shadowHeight = shadowBottomPoint.y - shadowTopPoint.y;

                shadowSvg.setAttribute('y', shadowY);
                shadowSvg.setAttribute('height', Math.max(0, shadowHeight));
                shadowSvg.setAttribute('width', SCREEN_WIDTH); // Ensure shadow width matches screen width

                rayTopLsObj.setAttribute('x1', lsX);
                rayTopLsObj.setAttribute('y1', lsY);
                rayTopLsObj.setAttribute('x2', objX);
                rayTopLsObj.setAttribute('y2', objY_top);

                rayTopObjScreen.setAttribute('x1', objX);
                rayTopObjScreen.setAttribute('y1', objY_top);
                rayTopObjScreen.setAttribute('x2', shadowTopPoint.x);
                rayTopObjScreen.setAttribute('y2', shadowTopPoint.y);

                rayBottomLsObj.setAttribute('x1', lsX);
                rayBottomLsObj.setAttribute('y1', lsY);
                rayBottomLsObj.setAttribute('x2', objX);
                rayBottomLsObj.setAttribute('y2', objY_bottom);

                rayBottomObjScreen.setAttribute('x1', objX);
                rayBottomObjScreen.setAttribute('y1', objY_bottom);
                rayBottomObjScreen.setAttribute('x2', shadowBottomPoint.x);
                rayBottomObjScreen.setAttribute('y2', shadowBottomPoint.y);

                currentObjectTypeSpan.textContent = objectType;

                switch (objectType) {
                    case 'Opaque':
                        objectSvg.style.fill = '#888888';
                        objectSvg.style.stroke = '#333333';
                        objectSvg.style.opacity = '1';
                        shadowSvg.style.opacity = '1';
                        shadowSvg.style.filter = 'none';
                        shadowSvg.style.display = 'block';
                        rayTopLsObj.style.display = 'block';
                        rayBottomLsObj.style.display = 'block';
                        rayTopObjScreen.style.display = 'block';
                        rayBottomObjScreen.style.display = 'block';
                        currentShadowStateSpan.textContent = 'Dark & Clear';
                        break;
                    case 'Translucent':
                        objectSvg.style.fill = 'rgba(255, 255, 255, 0.5)';
                        objectSvg.style.stroke = '#888888';
                        objectSvg.style.opacity = '1';
                        shadowSvg.style.opacity = '0.7';
                        shadowSvg.style.filter = 'url(#fuzzyShadow)';
                        shadowSvg.style.display = 'block';
                        rayTopLsObj.style.display = 'block';
                        rayBottomLsObj.style.display = 'block';
                        rayTopObjScreen.style.display = 'block';
                        rayBottomObjScreen.style.display = 'block';
                        currentShadowStateSpan.textContent = 'Lighter & Fuzzy';
                        break;
                    case 'Transparent':
                        objectSvg.style.fill = 'rgba(0, 122, 255, 0.2)';
                        objectSvg.style.stroke = '#007AFF';
                        objectSvg.style.opacity = '1';
                        shadowSvg.style.opacity = '0';
                        shadowSvg.style.filter = 'none';
                        shadowSvg.style.display = 'none';
                        rayTopLsObj.style.display = 'none';
                        rayBottomLsObj.style.display = 'none';
                        rayTopObjScreen.style.display = 'none';
                        rayBottomObjScreen.style.display = 'none';
                        currentShadowStateSpan.textContent = 'No Shadow';
                        break;
                }
            } catch (error) {
                console.error("Error updating visuals:", error);
            }
        }

        function setActiveButton(activeButton) {
            [opaqueBtn, translucentBtn, transparentBtn].forEach(btn => {
                btn.classList.remove('active');
            });
            activeButton.classList.add('active');
            objectType = activeButton.textContent; 
            updateVisuals();
        }

        lightDistanceSlider.addEventListener('input', (e) => {
            lightDistance = parseFloat(e.target.value);
            updateVisuals();
        });

        objectSizeSlider.addEventListener('input', (e) => {
            objectSize = parseFloat(e.target.value);
            updateVisuals();
        });

        opaqueBtn.addEventListener('click', () => setActiveButton(opaqueBtn));
        translucentBtn.addEventListener('click', () => setActiveButton(translucentBtn));
        transparentBtn.addEventListener('click', () => setActiveButton(transparentBtn));

        // AUTO MODE: URL Parameter Support
        function applyURLParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            
            // Check if we have URL parameters
            if (urlParams.toString().length === 0) {
                return; // MANUAL mode - no parameters
            }
            
            console.log('AUTO MODE: Applying URL parameters', Object.fromEntries(urlParams));
            
            // Light distance parameter - accepts 'lightDistance' or 'distance'
            const lightDistanceValue = urlParams.get('lightDistance') || urlParams.get('distance');
            if (lightDistanceValue !== null) {
                const distance = parseFloat(lightDistanceValue);
                if (!isNaN(distance) && distance >= 1 && distance <= 10) {
                    lightDistanceSlider.value = distance;
                    lightDistance = distance;
                    updateVisuals();
                }
            }
            
            // Object type parameter - accepts 'objectType' or 'type'
            const objectTypeValue = urlParams.get('objectType') || urlParams.get('type');
            if (objectTypeValue !== null) {
                const type = objectTypeValue.toLowerCase();
                if (type === 'opaque') {
                    setActiveButton(opaqueBtn);
                } else if (type === 'translucent') {
                    setActiveButton(translucentBtn);
                } else if (type === 'transparent') {
                    setActiveButton(transparentBtn);
                }
            }
            
            // Object size parameter - accepts 'objectSize' or 'size'
            const objectSizeValue = urlParams.get('objectSize') || urlParams.get('size');
            if (objectSizeValue !== null) {
                const size = parseFloat(objectSizeValue);
                if (!isNaN(size) && size >= 1 && size <= 10) {
                    objectSizeSlider.value = size;
                    objectSize = size;
                    updateVisuals();
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            updateVisuals();
            setActiveButton(opaqueBtn);
            // Apply URL parameters after initialization
            setTimeout(() => {
                applyURLParameters();
            }, 100);
        });
    </script>
</body>
</html>